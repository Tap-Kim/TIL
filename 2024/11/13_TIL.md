# 리액트 렌더링과 커밋

컴포넌트가 화면에 표시되기 전에 리액트에서 렌더링하는 과정을 살펴보자.

> 렌더링 트리거 -> 컴포넌트 렌더링 -> DOM 커밋

## 1. 렌더링 트리거

컴포넌트 렌더링에는 두가지 이유가 있는다

1. 컴포넌틔 **초기 렌더링**
2. 컴포넌트(또는 그 상위 컴포넌트 중 하나)의 상태가 업데이트

앱이 시작되면 초기 렌더링을 트리거해야 한다. 프레임워크와 샌드박스는 이 코드를 숨기는 경우가 있지만, 대상 DOM 노드로 [createRoot](https://react.dev/reference/react-dom/client/createRoot)를 호출한 다음 컴포넌트로 해당 렌더링 메서드를 호출하면 된다.

### 상태 업데이트시 리렌더링

컴포넌트가 처음 렌더링되면 `set` 함수를 사용하여 상태를 업데이트하여 추가 렌더링을 트리거할 수 있다. 컴포넌트의 **상태를 업데이트하면 렌더링이 자동으로 대기열에 추가**된다. (식당에서 손님이 첫 주문을 한 후 갈증이나 배고픔의 상태에 따라 차, 디저트 등 다양한 음식을 주문하는 것을 상상할 수 있다).

## 2. 컴포넌트 렌더링

렌더링을 트리거한 후 리액트는 컴포넌트를 호출하여 화면에 표시할 내용을 파악한다. "렌더링"은 리액트가 컴포넌트를 호출하는 것.

- **초기 렌더링 시** 리액트는 루트 컴포넌트를 호출한다.
- **후속 렌더링**에서 리액트는 상태 업데이트가 렌더링을 트리거한 함수 컴포넌트를 호출한다.

업데이트된 컴포넌트가 다른 컴포넌트를 반환하면 리액트는 그 컴포넌트를 다음에 렌더링하고, 그 컴포넌트 역시 무언가를 반환하면 그 컴포넌트를 다음에 렌더링하는 식으로 **재귀적인 프로세스**를 수행한다. 이 프로세스는 중첩된 컴포넌트가 더 이상 존재하지 않을 때까지 계속되고 리액트는 화면에 표시해야 할 내용을 정확히 파악한다.

```jsx
export default function Gallery() {
  return (
    <section>
      <h1>Inspiring Sculptures</h1>
      <Image />
      <Image />
      <Image />
    </section>
  );
}

function Image() {
  return (
    <img
      src="https://i.imgur.com/ZF6s192.jpg"
      alt="'Floralis Genérica' by Eduardo Catalano: a gigantic metallic flower sculpture with reflective petals"
    />
  );
}
```

![](https://i.imgur.com/ZF6s192.jpg)

초기 렌더링 중에 리액트는 `<section>`, `<h1>`, 3개의 `<img>` 태그에 대한 [DOM 노드를 생성](https://developer.mozilla.org/docs/Web/API/Document/createElement)하고, 다시 렌더링하는 동안 리액트는 이전 렌더링 이후 변경된 속성이 있다면 어떤 속성이 있는지 계산한다. 다음 단계인 **커밋 단계가 될 때까지 해당 정보로 아무 작업도 하지 않다**.

> 참고: 렌더링은 항상 순수한 계산이어야한다. 동일한 입력이 주어지면 컴포넌트는 항상 동일한 JSX를 반환해야한다. 렌더링 전에 존재했던 어떤 객체나 변수도 변경해서는 안된다.
>
> 그렇지 않으면 코드베이스가 복잡해짐에 따라 혼란스러운 버그와 예측 불가능한 동작이 발생한다. "Strict Mode"에서 갭라시 리액트는 각 컴포넌트의 함수를 두 번 호출해 불순한 함수로 인한 실수를 표면화하는데 도움이 된다.

## 3. 리액트가 DOM에 변경 사항 커밋

컴포넌트를 렌더링(호출)한 후 리액트는 DOM을 수정한다.

- **최초 렌더링**의 경우, 리액트는 `appendChild()` DOM API를 사용해 생성한 모든 DOM 노드를 화면에 배치한다다.
- **다시 렌더링**하는 경우, 리액트는 DOM이 최신 렌더링 출력과 일치하도록 하기 위해 필요한 최소한의 연산(렌더링하는 동안 계산!)을 적용한다.

**리액트는 렌더링 간에 차이가 있는 경우에만 DOM 노드를 변경한다**. 예를 들어, 매초 부모로부터 전달된 다른 props로 다시 렌더링하는 컴포넌트가가 있는데 `<input>`에 텍스트를 추가하여 value를 업데이트할 수 있지만 컴포넌트가가 다시 렌더링될 때 텍스트가 사라지지 않는 방법에 유의하자.

```jsx
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}
```

마지막 단계시 리액트는 `h1` 콘텐츠만 새로운 업데이트되기 때문에 작동된다. `input`이 지난번과 같은 위치에 JSX에 표시되므로 리액트에선 `input`을 건드리지 않는다.

## 에필로그: 브라우저 페인트

렌더링이 완료되고 리액트가 DOM을 업데이트하면 브라우저는 화면을 다시 페인트한다. 이 프로세스를 "브라우저 렌더링"이라고 한다. 하지만 문서에서 혼동을 피하기 위해 "페인팅"이라고 부른다.

![](https://react.dev/images/docs/illustrations/i_browser-paint.png)

## 요약

- 리액트 앱의 모든 화면 업데이트는 세 단계로 진행된다.

  1. 트리거
  2. 렌더
  3. 커밋

- Strict Mode를 사용하면 구성 요소의 실수를 찾을 수 있다.
- 렌더링 결과가 지난번과 동일하다면 리액트는 DOM을 건드리지 않는다.

# 출처

- [Render and Commit](https://react.dev/learn/render-and-commit)
