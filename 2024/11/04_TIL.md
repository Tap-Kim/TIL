# Open Graph (링크의 미리보기 제목, 설명, 이미지를 결정하는 open graph 태그)

많은 SNS에서 링크의 미리보기, 제목, 설명, 이미지를 제공한다. 이는 어떻게 나오는 걸까?

## HTML 문서의 HEAD와 메타 정보

기본적으로 웹사이트는 HTML문서로 작성되고 head, body가 있다. 이 head에는 메타 데이터들이 HTML 태그를 통해 담겨있다.

메타 데이터란? 해당 웹페이지를 구성하는 여러 구조화된 정보들. 즉, 제목, 설명, 이미지 등을 아예 명시적으로 웹페에지에 직접 표기해 준 것.

![](https://cdn.prod.website-files.com/5f1008192dda2baf6f4e16c3/5f34b22f3a168c3b5d9f2845_Screen-Shot-2016-05-03-at-11-16-50-PM-1.png)

직접 표기해주는 이유? 크롤러도 하나의 소프트웨어라 HTML 문서 확인시 뭐가 어떤 내용인지 파악하기 어렵다. 따라서 웹사이트가 직접 적어서 알려줘야한는 것. 그리고 이런 메타 데이터를 표기하는 방법을 기본 방법(HTML5 title, description 태그 등)을 제외한 제 3의 방법 중 비교적 통일되고 일정된 방법인 페이스북의 OG(Open Graph)프로토콜이 있다.

![](https://cdn.prod.website-files.com/5f1008192dda2baf6f4e16c3/5f34b22f72cfa9400642fc7d_Open-Graph------------.png)

구체적인 작동원리는

1. 사용자가 링크를 입력창에 입력합니다.
2. 페이스북, 네이버 블로그, 카카오톡은 입력창의 문자열이 "링크"라는 것을 파악합니다. (흔히 말하는 정규표현식으로 해당 문자열이 링크라는 것을 알아냅니다.)
3. 링크라는 것이 파악되면 페이스북, 네이버 블로그, 카카오톡의 크롤러는 미리 그 웹사이트를 방문해서 HTML head의 오픈그래프(Open Graph) 메타 데이터를 긁어옵니다.
4. 이중에서도 og:title, og:description, og:image가 각각 제목, 설명, 이미지의 정보를 나타냅니다.
5. 그리고 그 정보를 바탕으로 미리보기 화면을 생성해주게 됩니다.

## 페이스북의 오픈그래프 프로토콜

[오픈 그래프](http://ogp.me/) 웹 사이트에서 오픈 그래프는 페이스북에서 처음 만들어 졌고, Dublin Core, link-rel canonical, Microformats, 그리고 RDFa로부터 영감을 받았다.

오픈 그래프는 HTML 문서의 메타정보를 쉽게 표시하기 위해 메타정보에 해당하는 제목, 설명, 문서 타입, 대표 URL 등 다양한 요소를 통해 통일해서 정의한 프로토콜이다. 네이버, 카카오톡도 이 간편을 위해 사용중이다.

![](https://cdn.prod.website-files.com/5f1008192dda2baf6f4e16c3/5f34b22f6760b077c9b7da15_Screen-Shot-2016-05-03-at-11-54-26-PM.png)

기본적으로 메타 데이터는 title, description, image, url이 이다.(여기서 canonicanl link, 즉 표준 링크란 같은 콘텐츠를 가리키는 여러 개의 URL 중에서 대표 하나의 URL을 말한다.) 이는 현실에 있는 실제 대상들을 가상의 그래프 기반 데이터베이스로 표현하려는 페이스북의 계획의 중요한 요소이고, 하나의 대상은 원칙적으로 단 하나의 링크만 참조되어야하기 때문이다.

## OG 적용 여부, 어떻게?

페이스북은 오픈 그래프에 개발자와 마케터의 디버깅을 지원하기 위해 [sharing-debugger](https://developers.facebook.com/tools/debug/sharing/)를 지원한다.

![](https://cdn.prod.website-files.com/5f1008192dda2baf6f4e16c3/5f34b22f8cfd7d8388e12c65_Screen-Shot-2016-05-04-at-12-21-04-AM.png)

## 미리보기가 바뀌지 않은 이유. 캐시

프로그래밍의 세계에서 캐싱(Caching)은 반복적으로 호출되는 특정한 데이터를 캐시 메모리에 일종의 "임시"로 저장하여 다음 번에 호출될 때 더 빨리 해당 데이터를 공급해주는 것을 말한다.

구체적으로는 데이터베이스에 저장된 어떤 정보를 한 번 불러온 후 캐시 메모리에 저장해놓거나, 어떤 HTML, CSS, JavaScript로 이뤄진 웹문서 전체 혹은 이미지 전체를 캐싱하기도 한다. (전자에는 Memcached, Redis와 같은 시스템들이, 후자는 흔히들 "CDN"이라고 부르는 시스템들이 속함)

사용자들 입장에서는 더 빨리 웹사이트나 이미지가 로딩되서 좋고, 서비스측에서는 데이터베이스 구동에 들어가는 막대한 서버 자원을 절약할 수 있어서 좋다. 일반적으로 캐싱에는 TTL(time-to-live)라는 소멸 시효가 걸려있는데, 이 소멸시효가 지나지 않은 경우 계속적으로 이미 캐싱된 데이터를 참조해서 불러올 수 있다.

실제로 서버에서 내려주는 HTML의 OG는 바뀌었을지라도 이미 캐시된 웹문서가 내려지는 상황일수 있다. 즉, TTL이 만료되기 전까지 미리보기는 바뀌지 않는다.

이 경우 페이스북은 다행히 캐싱을 리로드할 수 있는 버튼을 ["Sharing Debugger](https://developers.facebook.com/tools/debug/)"를 통해서 지원하고 있다.

## 클릭2 미스터리

미리보기 제목, 설명, 이미지와 관련된 사소한 현상인데, 가끔 내가 바로 쓴 글을 페이스북에 올리면 바로 조회수가 2로 올라가는 현상을 볼 수 있다. 앞서 말한 것과 같이 크롤러가 우리 사이트를 한 번 "미리" 방문하는 현상 때문에 조회수가 1 올라간다.

구글과 같이 방금 방문한 사람이 크롤러라는 것을 명시해주는 경우도 있지만, 페이스북처럼 크롤러라는 것을 전혀 알 수 없게 해놓는 경우도 있다. 즉, 미리보기 화면이 로딩되는 것은 곧 나의 웹사이트를 페이스북에서 익명 유저가 1번 방문하는 것과 동일하다는 것을 인지해야 한다.

## 결론

특히 설치링크라면 더더욱 사소한 문구 하나의 차이가 큰 설치율의 증감을 초래할 수도 있다.

주의할점

1. og:title, og:description, og:image를 HTML의 head에 반드시 넣고, 제대로 반영되었는지를 "Sharing Debugger"를 통해서 확인한다.
2. 실제로 카카오톡, 페이스북, 네이버 블로그 등 사용하고자 하는 마케팅 채널에 링크를 넣고 미리보기 화면을 확인한다. (실제 보여지는 이미지가 사이즈가 각 서비스마다 3. 다르기 때문에 반드시 주의할 것)
3. 가능하다면 A/B 테스팅을 통해서 어떤 문구나 이미지가 가장 좋은 효과를 보이는지 확인한다.

## 출처

- [AB180 - 링크의 미리보기 제목, 설명, 이미지를 결정하는 open graph 태그](https://blog.ab180.co/posts/open-graph-as-a-website-preview)
- [The Open Graph protocol](https://ogp.me/)
