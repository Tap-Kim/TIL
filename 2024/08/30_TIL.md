# 코드 스플릿

## 정리

- 자바스크립트의 로드 속도는 페이지 성능에 큰 영향을 받는다. 따라서 더 작은 청크로 분할하고 시작시 페이지가 기능하는 것에만 필요한 것만 다운로드시 로드 반응성이 크게 향상되고, 이는 [INP](https://web.dev/articles/inp)에 대한 상호작용을 개선할 수 있다.
- 되도록 번들러를 사용해서 자동으로 코드 스플릿 및 코드 압축 등과 같은 청크 단위의 리소스를 다운받도록 유도하고, 상황에 따라 정적, 동적 import를 진행하여 사용자 상호작용시 불필요한 로드를 막을 수 있다.
- 웹팩을 활용하여 `SplitChunksPlugin` 옵션 사용시 동적, 정적 청크를 초기, 동기, 모든 상황에 따라 초기 청크간에 로드가 가능하게 설정이 가능하며, 큰 스크립트를 여러개의 작은 청크로 나누게하는 옵션을 활용하자.
- 압축하여 스크립트 크기가 작으면, 재방문 사용자가 리소스 검색할 가능성이 높아서 캐싱에 용이하고 상호작용 시간이 더 빨라지나 불필요한 압축으로 인해 브라우저 캐시가 준비 되지 않는 상태가 되어 네트워크 왕복 시간이 늘어날 수 있다. 상황에 맞게 효율성, 압축효과, 스크립트 평가 시간 간의 균형을 맞춰가며 최적화하자.

### 참고

- 주요 키워드: code-split, chunk, TBT, INP, bundler, streaming compilation, caching, compression, evaluation
- 관련 기술: webpack, bundler, Lighthouse, ChromeDevTools, dynamic import(),

## 무엇을 알았는지

페이지가 큰 자바스크립트를 다운로드, 파싱, 컴파일시 일정 시간 동안 응답하지 않을 수 있다. 이는 메인 스레드에서 파싱되고 컴파일되기 때문에 메인스레드가 차단되는 경우인데, 너무 오래 걸리게되면 UX에 좋지 않아 이를 해결하기 위한 해결책중 코드 스플릿이 있고 빠르게 로드할 수 있는 것들을 분할해서 나중에 로드하도록 지연시키는 방법이 있다.

Lighthouse에서는 자바스크립트 실행이 2초이상 걸리면 *경고*를 표시하고, 3.5초 이상 걸리면 *실패*를 나타낸다. 이는 사용자가 페이지와 상호작용하는 시간이 자바스크립트를 처리하고 실행하는 멩니 스레드 작업이 실행되는 순간과 일치하면 상호작용의 [입력 지연](https://web.dev/articles/optimize-input-delay)이 증가할 것으로 판단하기 때문이다.

그 이상으로 과도한 자바스크립트 실행 및 파싱은 초기 로드에도 문제가 생긴다. load responsiveness metric인 [TBT](https://web.dev/articles/tbt)는 [INP](https://web.dev/articles/inp)와 높은 상관 관계가 있고, 이는 사용자가 초기 로드 중에 상호 작용을 시도할 경향이 높다는 것을 의미한다.

[ChromeDevTools의 커버리지 도구](https://developer.chrome.com/docs/devtools/coverage/)를 사용해서 자바스크립트의 어떤 부분이 사용되지 않는지 식별할 수 있다.

### 동적 import와 번들러

자바스크립트의 번들은 두 부분을 나뉜다.

- 페이지 로드시 필요한 자바스크립트임으로 다른 때에는 로드할 수 없다.
- 나중에 로드할 수 있는 나머지 자바스크립트로, 보통 사용자가 페이지에 주어진 상호작을 하는 시점에 로드된다.

코드 스플릿은 동적 `import()`를 수행할 수 있다. 이 구문은 `<script>` 시작 중에 주어진 자바스크립트 리소스를 요청하는 요소와 달리 페이지 수명주기 중에 나중에 자바스크립트 리소스를 요청한다.

```js
document.querySelectorAll("#myForm input").addEventListener(
  "blur",
  async () => {
    // 구조분해 할당을 통해 export된 validate-form이라는 모듈에서 가져온다.
    const { validateForm } = await import("/validate-form.mjs");

    validateForm();
  },
  { once: true }
);
```

위 스니펫에서 `validate-form.mjs` 모듈은 사용자가 form 필드에서 blur 동작을 수행할때만 다운로드 및 파싱을 실행한다.

webpack , Parcel , Rollup , esbuild와 같은 자바스크립트 번들러는 소스 코드에서 동적 호출을 만날 때마다 번들을 더 작은 청크로 분할하도록 구성한다. 대부분은 이 작업을 자동으로 수행하지만 esbuild에서는 사용자가 이 최적화를 선택해야한다.

### 가능하면 번들러를 사용하자

일반적으로 자바스크립트 모듈중 번들러를 사용해서 코드를 처리하고 최적화하며 코드 스플릿도 포함된다. 압축 효과는 번들 크기에 따라 증가하지만 번들러는 스크립트 평가로 인해 긴 작업이 발생할 정도로 번들리 너무 크지 않도록 한다.

또한 번들러는 네트워크를 통해 많은 수의 번들되지 않는 모듈을 전송하는 문제를 피한다. 자바스크립트 모듈을 사용하는 아키텍처는 크고 복잡한 모듈 트리를 갖는 경향이 있따. 모듈 트리가 번들되지 않으면 각 모듈은 별도의 HTTP 요청을 나타내며 모듈을 번들하지 않으면 웹 앱의 상호 작용이 지연될 수 있다. 리소스 `<link rel="modulepreload">` 힌트를 사용해서 큰 모듈을 일찍 로드할 수 있지만 자바스크립트 번들은 여전히 로딩 성능 관점이 더 바람직하다.

### 실수로 스트리밍 컴파일을 비활성화하지 말자

Chromium의 자바스크립트 V8 엔진은 프로덕션 코드가 효율적으로 로드되기 위해 다양한 최적화를 제공한다. 이중 하나가 `스트리밍 컴파일`이라고 하고, 브라우저에 스트리밍된 HTML의 증분 파싱과 마찬가지로 네트워크에 도착 즉시 스트리밍된 자바스크립트 청크를 컴파일 한다.

Chromium에서 웹 애플리케이션에 대한 스트리밍 컴파일이 수행되돍 하는 방법은 여러가지다.

- **자바스크립트 모듈을 사용하지 않도록 프로덕션 코드를 변환**: 번들러는 컴파일 대상에 따라 코드를 변환할 수 있으며, 대상은 특정 환경에 따라 다르다. V8은 모듈을 사용하지 않는 모든 자바스크립트 코드에 스트리밍 컴파일을 적용하고 번들러를 구성하여 자바스크립트 모듈과 그 기능을 사용하지 않는 구문으로 변환하도록 번들러를 구성할 수 있다.
- **자바스크립트 모듈을 프로덕션에 배포하려면 `.mjs` 확장자를 사용하자**: V8은 `.js` 확장자를 사용하여 프로덕션 환경에서 자바스크립트 모듈을 배포할 때 스트리밍 컴파일을 효과적으로 거부할 수 있다. 자바스크립트 모듈에 `.mjs` 확장자를 사용하는 경우 V8은 모듈 기반 자바스크립트 코드에 대한 스트리밍 컴파일이 중단되지 않도록 보장한다.

이런 고려사항 때문에 코드 스플릿을 기피하지 말자. 이는 사용자에게 빠르게 제공될 수 있는 효과적인 방법이다.

### 웹팩

웹팩에는 번들러가 자바스크립트 파일을 분할하는 방법을 구성할 수 있는 `SplitChunksPlugin`이라는 플러그인이 제공된다. 웹팩은 동적 `import()`문과 정적 `import`문 모두 인식하며, 구성에 chunks 옵션을 지정해서 `SplitChunksPlugin`의 동작을 수정할 수 있다.

- `chunks: async`는 기본값이며 동적 `import()` 호출을 나타낸다.
- `chunks: initial`은 정적 `import` 호출을 나타낸다.
- `chunks: all` 동적 `import()`와 정적 `import`를 모두 포함하므로 비동기 가져오기와 초기 가져오기 간에 청크를 공유할 수 있다.

```js
/* main.js */

// 초기 페이지 로드 시 필요한 애플리케이션별 청크
import myFunction from "./my-function.js";

myFunction("Hello world!");

// 특정 조건이 충족되면 초기 청크와 함께 번들로 제공되는 것이 아니라 필요에 따라 별도의 청크가 다운로드한다.

if (condition) {
  // 최상위 대기 상태가 사용 가능하다고 가정. 자세한 정보:https://v8.dev/features/top-level-await
  await import("/form-validation.js");
}
```

- 웹팩이 초기 청크로 분류하는 `main.js` 청크에는 `main.js` 및 `./my-function.js` 모듈이 포함되어 있다.
- `async` 청크로 `form-validation.js`만 포함한다. 이 청크는 condition이 truthy한 경우에만 다운로드한다.

위와 같이 구성한다면 실제 필요할 때까지 `form-validation.js` 청크 로드를 연기할 수 있고, 스크립트 평가를 줄여 응답성을 개선할 수 있다.

`SplitChunksPlugin` 구성을 변경하여 지정하면 `chunks: initial`코드가 초기 청크에서만 분할된다. 이는 정적으로 가져오거나 웹 팩의 [entry](https://webpack.js.org/concepts/entry-points/) 속성에 나열된 청크와 같은 청크이다. 앞의 예를 살펴 보면 결과 청크는 단일 스크립트 파일에 있는 `form-validation.js`와 `main.js`의 조합으로 되어 잠재적으로 초기 로드 성능이 저하될 수 있다.

`SplitChunksPlugin` 옵션은 큰 스크립트를 여러개의 작은 스크립트로 분리하도록 구성한다. 예를 들어 [maxSize](https://webpack.js.org/plugins/split-chunks-plugin/#splitchunksmaxsize)를 지정한 것을 초과한 경우 별도의 파일로 분할하도록 지시하는 옵션이다. 이렇게 작게 나뉘어 로드하게 되면 응답성이 향상되고 CPU 집약적 스크립트 평가가 더 작은 작업으로 나뉘어 장시간 메인 스레드를 차단할 가능성이 줄어든다.

또한 더큰 자바스크립트를 생성한다는 것은 스크립트가 캐시 무효화로 인해 더 큰 피해를 입을 가능성이 있다. 예를 들어, 프레임워크와 first-party 애플리케이션 코드가 모두 포함된 매우 큰 스크립트를 제공시 프레임워크만 제공되고 번들 리소스의 다른 것들을 업데이트되지 않으면 전체 번들이 무효화될 수 있다.

반면에 스크립트 파일이 작을수록 재방문자가 캐시에서 리소스를 검색할 가능성이 높아져 재방문시 페이지 로드가 더 빨라진다. 하지만 작은 파일은 큰 파일보다 압축윽의 이점이 적고, 브라우저 캐시가 준비되지 않은 경우 페이지 로드시 네트워크 왕복 시간이 늘어날 수 있다.

때문에 캐시 효율성, 압축효과, 스크립트 평가 시간 간의 균형을 맞추도록 주의해야한다.

### 출처

- [code-split-javascript](https://web.dev/learn/performance/code-split-javascript)
